/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */

'use strict';

const debug = require('debug')('express:router:route');
const flatten = require('array-flatten');
const Layer = require('./layer');
const methods = require('methods');

const slice = Array.prototype.slice;
const toString = Object.prototype.toString;

module.exports = Route;

function Route(path) {
  this.path = path;
  this.stack = [];

  debug('new %o', path);

  this.methods = {};
}

Route.prototype._handles_method = function _handles_method(method) {
  if (this.methods._all) {
    return true;
  }

  let name = typeof method === 'string' ? method.toLowerCase() : method;

  if (name === 'head' && !this.methods['head']) {
    name = 'get';
  }

  return Boolean(this.methods[name]);
};

Route.prototype._options = function _options() {
  let methods = Object.keys(this.methods);

  if (this.methods.get && !this.methods.head) {
    methods.push('head');
  }

  for (let i = 0; i < methods.length; i++) {
    methods[i] = methods[i].toUpperCase();
  }

  return methods;
};

Route.prototype.dispatch = function dispatch(req, res, done) {
  let idx = 0;
  const stack = this.stack;
  let sync = 0;

  if (stack.length === 0) {
    return done();
  }

  let method = typeof req.method === 'string' ? req.method.toLowerCase() : req.method;

  if (method === 'head' && !this.methods['head']) {
    method = 'get';
  }

  req.route = this;

  next();

  function next(err) {
    if (err && (err === 'route' || err === 'router')) {
      return done(err);
    }

    if (++sync > 100) {
      return setImmediate(next, err);
    }

    const layer = stack[idx++];

    if (!layer) {
      return done(err);
    }

    if (layer.method && layer.method !== method) {
      return next(err);
    }

    if (err) {
      layer.handle_error(err, req, res, next);
    } else {
      layer.handle_request(req, res, next);
    }

    sync = 0;
  }
};

Route.prototype.all = function all() {
  const handles = flatten(slice.call(arguments));

  for (let i = 0; i < handles.length; i++) {
    const handle = handles[i];

    if (typeof handle !== 'function') {
      const type = toString.call(handle);
      const msg = 'Route.all() requires a callback function but got a ' + type;
      throw new TypeError(msg);
    }

    const layer = Layer('/', {}, handle);
    layer.method = undefined;

    this.methods._all = true;
    this.stack.push(layer);
  }

  return this;
};

methods.forEach(function (method) {
  Route.prototype[method] = function () {
    const handles = flatten(slice.call(arguments));

    for (let i = 0; i < handles.length; i++) {
      const handle = handles[i];

      if (typeof handle !== 'function') {
        const type = toString.call(handle);
        const msg = 'Route.' + method + '() requires a callback function but got a ' + type;
        throw new Error(msg);
      }

      debug('%s %o', method, this.path);

      const layer = Layer('/', {}, handle);
      layer.method = method;

      this.methods[method] = true;
      this.stack.push(layer);
    }

    return this;
  };
});
